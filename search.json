[
  {
    "objectID": "Fondamentaux.html",
    "href": "Fondamentaux.html",
    "title": "Les fondamentaux de Python",
    "section": "",
    "text": "Qu’est ce qu’une variable ? Une variable est un conteneur dans lequel tu peux stocker différents types de données : des nombres, des chaines de caractères, ou d’autres objets.\nPar exemple a = 15 est une variable nomée a avec pour valeur 15.\nNous pouvons contaster :\n\nL’affectation (=)\nPython est un langage à typage dynamique, c’est-à-dire que le type des variables est déterminé lors de l’exécution du programme.\nSensible à la casse, la variable “A” et “a” sont deux variables différentes.\nL’instruction Print permet d’imprimer plusieurs variables en même temps avec (,).\nPlusieurs valeurs à plusieurs variables ou plusieurs variables à plusieurs valeurs sur une seule ligne.\nLa dénomination des variables comportent :\n\nLa casse camel : testVariableBox\nLa casse Pascal : TestVariableBox\nLa casse serpent : test_variable_box\n\nEvite de:\n\nNommer des variables en commançant par des chiffres\nSe servir de symboles comme des espaces ou des tirets\nMixer des chaînes de caractères et des nombres entiers à l’intérieur de la concaténation\n\n\n\nAffectation simple\n\n\nma_variable = 15\nprint(ma_variable)\n\n15\n\n\n\nAffectation à multiples variables\n\n\na, b, c = \"Ananas\", \"Banane\", \"Coco\"\n\nprint(a)\nprint(b)\nprint(c)\n\nAnanas\nBanane\nCoco\n\n\n\nAffectation de la même valeur\n\n\na = b = c = \"Coco\"\nprint(a)\nprint(b)\nprint(c)\n\nCoco\nCoco\nCoco\n\n\n\n\nEn Python, les données courantes incluent : * les entiers (int) : des nombres sans décimale. + Exemple : 7, -1.\n\nNombres Complexes (complex) : des nombres avec une partie réelle et une partie imaginaire.\n\nExemple : 4 + 2j.\n\nFlottants (float) : des avec au moins une décimale.\n\nExemple : 2.15, -0.008.\n\nChaîne de caractères (str) : une suite de caractères, délimitée par des guillemets simples ou doubles.\n\nExemple : \"Hello Ményssa !\"\n\nBooléens (bool) : souvent le résultat d’expressions, de comparaison ou de conditions logiques.\n\nIls représentent uniquement deux valeurs : True (Vrai) et False (Faux).\n\n\nLa fonction type()\n\n# Pour connaître le type de ton objet\ntype(\"Bonjour\")\n\nstr\n\n\nExemple : Vérifions le type de chaque variable en impliquant une phrase réponse\n\n# Définition de différentes variables\nprenom = \"Mareva\"\nage = 21\ntaille = 1.63\netudiant = True\nen_alternance = False\n\n\n# Vérifications\nprint(\"La variable prenoms est de type : \", type(prenom))\n\nLa variable prenoms est de type :  &lt;class 'str'&gt;\n\n\n\nprint(\"La variable age est de type : \", type(age))\n\nLa variable age est de type :  &lt;class 'int'&gt;\n\n\n\nprint(\"La variable taille est de type : \", type(taille))\n\nLa variable taille est de type :  &lt;class 'float'&gt;\n\n\n\nprint(\"La variable etudiant est de type : \", type(etudiant))\n\nLa variable etudiant est de type :  &lt;class 'bool'&gt;\n\n\n\nprint(\"La variable en_alternance est de type : \", type(en_alternance))\n\nLa variable en_alternance est de type :  &lt;class 'bool'&gt;\n\n\n\n\n\nSouvent appelée “casting” en programmation, la conversion de type est une manière de convertir une valeur d’un type donné en un autre type.\nEn Python, il existe différentes fonctions intégrées pour réaliser ces conversions entre les types de base comme vue précédemment : les entiers (int), les chaînes de caractères(str), les booléens (bool), et les nombres à virgule flottante (float).\nVoici des exemples :\n\nConversion en Entier (int)\n\n\n# Depuis une chaîne de caractères : convertion de la chaîne \"987\" en entier 987\nchaine = \"987\"\ndepartement = int(chaine)  \n\n# Depuis un booléen : convertion de True en entier 0 \nvrai = False\nentier = int(False)  \n\n# Depuis un float : convertion d'un nombre décimal 10,02 en 10 entier (troncature, pas d'arrondi)\nflottante = 10.02\nentier = int(flottante)  \n\n\nConversion en chaine de caractère (str)\n\n\n# Depuis un entier ou un float : convertion de l'entier 987 en chaîne \"987\"\nentier = 987\nchaine = str(entier) \n\n# Depuis un booléen :\nvrai = True\nchaine = str(vrai)  # Convertion de True en \"True\"\n\n\nConversion en booléen (bool)\n\n\n# Depuis une chaîne de caractères : \n## Convertion d'une chaîne vide en False\nchaine1 = \"\"\nbooleen = bool(chaine1) \n## Convertion de \"Prog\" en True\nchaine2 = \"Prog\"\nbooleen1 = bool(chaine2)  \n\n# Depuis un nombre** : \n## Convertit 0 en False\nnombre1 = 0\nbooleen1 = bool(nombre1) \n## Convertit 987 en True\nnombre2 = 987\nbooleen2 = bool(nombre2)  \n\n\nConversion en Float(float)\n\n\n## Depuis une chaîne de caractères** :\nchaine = \"123.45\"\nflottant = float(chaine)  # Convertit la chaîne \"123.45\" en float 123.45\n\n## Depuis un entier** :\nentier = 100\nflottant = float(entier)  # Convertit l'entier 100 en float 100.0\n\n## Depuis un booléen** :\nvrai = True\nflottant = float(vrai)  # Convertit True en 1.0\n\n\n\n\nArithmétique : Addition (+), soustraction (-), multiplication (*), et division (/).\n\nsomme = 10 + 5       # Résultat: 15\ndifference = 10 - 5  # Résultat: 5\nproduit = 10 * 5     # Résultat: 50\nquotient = 10 / 5    # Résultat: 2.0\n\nModulo (%) retourne le reste de la division Puissance (**) élève un nombre à une certaine puissance.\n\nreste = 10 % 3       # Résultat: 1\npuissance = 2 ** 3   # Résultat: 8\npuissance_bis = 2 ^ 3\n\n\n\n\n\nLa concaténation (+) combine des chaînes\nLa répétition **(*)** répète une chaîne un certain nombre de fois.\n\n\nmessage = \"Bonjour\" + \" le monde\"  # Résultat: \"Bonjour le monde\"\necho = \"Ha\" * 3                    # Résultat: \"HaHaHa\"\n\n\n\n\nLes opérateurs d’affectation composés sont des raccourcis qui combinent une opération arithmétique ou binaire avec une affectation.\nEn gros, ils vous permettent d’effectuer une opération sur une variable et de lui réaffecter le résultat en une seule étape.\n\n# Initialisation de x\nx = 5\nprint(x)\n\n5\n\n\n\n# Ajouter et assigner\nx += 2  # x est maintenant 7\nprint(x)\n\n7\n\n\n\n# Soustraire et assigner\nx -= 3  # x est maintenant 4\nprint(x)\n\n4\n\n\n\n# Multiplier et assigner\nx *= 4  # x est maintenant 16\nprint(x)\n\n16\n\n\n\n# Diviser et assigner\nx /= 2  # x est maintenant 8\nprint(x)\n\n8.0\n\n\n\n# Division entière et assigner\nx //= 3  # x est maintenant 2\nprint(x)\n\n2.0\n\n\n\n# Modulo et assigner\nx %= 3  # x est maintenant 2\nprint(x)\n\n2.0\n\n\n\n# Exponentielle et assigner\nx **= 2  # x est maintenant 4\nprint(x)\n\n4.0"
  },
  {
    "objectID": "Fondamentaux.html#les-variables-types-natifs",
    "href": "Fondamentaux.html#les-variables-types-natifs",
    "title": "Les fondamentaux de Python",
    "section": "",
    "text": "Qu’est ce qu’une variable ? Une variable est un conteneur dans lequel tu peux stocker différents types de données : des nombres, des chaines de caractères, ou d’autres objets.\nPar exemple a = 15 est une variable nomée a avec pour valeur 15.\nNous pouvons contaster :\n\nL’affectation (=)\nPython est un langage à typage dynamique, c’est-à-dire que le type des variables est déterminé lors de l’exécution du programme.\nSensible à la casse, la variable “A” et “a” sont deux variables différentes.\nL’instruction Print permet d’imprimer plusieurs variables en même temps avec (,).\nPlusieurs valeurs à plusieurs variables ou plusieurs variables à plusieurs valeurs sur une seule ligne.\nLa dénomination des variables comportent :\n\nLa casse camel : testVariableBox\nLa casse Pascal : TestVariableBox\nLa casse serpent : test_variable_box\n\nEvite de:\n\nNommer des variables en commançant par des chiffres\nSe servir de symboles comme des espaces ou des tirets\nMixer des chaînes de caractères et des nombres entiers à l’intérieur de la concaténation\n\n\n\nAffectation simple\n\n\nma_variable = 15\nprint(ma_variable)\n\n15\n\n\n\nAffectation à multiples variables\n\n\na, b, c = \"Ananas\", \"Banane\", \"Coco\"\n\nprint(a)\nprint(b)\nprint(c)\n\nAnanas\nBanane\nCoco\n\n\n\nAffectation de la même valeur\n\n\na = b = c = \"Coco\"\nprint(a)\nprint(b)\nprint(c)\n\nCoco\nCoco\nCoco\n\n\n\n\nEn Python, les données courantes incluent : * les entiers (int) : des nombres sans décimale. + Exemple : 7, -1.\n\nNombres Complexes (complex) : des nombres avec une partie réelle et une partie imaginaire.\n\nExemple : 4 + 2j.\n\nFlottants (float) : des avec au moins une décimale.\n\nExemple : 2.15, -0.008.\n\nChaîne de caractères (str) : une suite de caractères, délimitée par des guillemets simples ou doubles.\n\nExemple : \"Hello Ményssa !\"\n\nBooléens (bool) : souvent le résultat d’expressions, de comparaison ou de conditions logiques.\n\nIls représentent uniquement deux valeurs : True (Vrai) et False (Faux).\n\n\nLa fonction type()\n\n# Pour connaître le type de ton objet\ntype(\"Bonjour\")\n\nstr\n\n\nExemple : Vérifions le type de chaque variable en impliquant une phrase réponse\n\n# Définition de différentes variables\nprenom = \"Mareva\"\nage = 21\ntaille = 1.63\netudiant = True\nen_alternance = False\n\n\n# Vérifications\nprint(\"La variable prenoms est de type : \", type(prenom))\n\nLa variable prenoms est de type :  &lt;class 'str'&gt;\n\n\n\nprint(\"La variable age est de type : \", type(age))\n\nLa variable age est de type :  &lt;class 'int'&gt;\n\n\n\nprint(\"La variable taille est de type : \", type(taille))\n\nLa variable taille est de type :  &lt;class 'float'&gt;\n\n\n\nprint(\"La variable etudiant est de type : \", type(etudiant))\n\nLa variable etudiant est de type :  &lt;class 'bool'&gt;\n\n\n\nprint(\"La variable en_alternance est de type : \", type(en_alternance))\n\nLa variable en_alternance est de type :  &lt;class 'bool'&gt;\n\n\n\n\n\nSouvent appelée “casting” en programmation, la conversion de type est une manière de convertir une valeur d’un type donné en un autre type.\nEn Python, il existe différentes fonctions intégrées pour réaliser ces conversions entre les types de base comme vue précédemment : les entiers (int), les chaînes de caractères(str), les booléens (bool), et les nombres à virgule flottante (float).\nVoici des exemples :\n\nConversion en Entier (int)\n\n\n# Depuis une chaîne de caractères : convertion de la chaîne \"987\" en entier 987\nchaine = \"987\"\ndepartement = int(chaine)  \n\n# Depuis un booléen : convertion de True en entier 0 \nvrai = False\nentier = int(False)  \n\n# Depuis un float : convertion d'un nombre décimal 10,02 en 10 entier (troncature, pas d'arrondi)\nflottante = 10.02\nentier = int(flottante)  \n\n\nConversion en chaine de caractère (str)\n\n\n# Depuis un entier ou un float : convertion de l'entier 987 en chaîne \"987\"\nentier = 987\nchaine = str(entier) \n\n# Depuis un booléen :\nvrai = True\nchaine = str(vrai)  # Convertion de True en \"True\"\n\n\nConversion en booléen (bool)\n\n\n# Depuis une chaîne de caractères : \n## Convertion d'une chaîne vide en False\nchaine1 = \"\"\nbooleen = bool(chaine1) \n## Convertion de \"Prog\" en True\nchaine2 = \"Prog\"\nbooleen1 = bool(chaine2)  \n\n# Depuis un nombre** : \n## Convertit 0 en False\nnombre1 = 0\nbooleen1 = bool(nombre1) \n## Convertit 987 en True\nnombre2 = 987\nbooleen2 = bool(nombre2)  \n\n\nConversion en Float(float)\n\n\n## Depuis une chaîne de caractères** :\nchaine = \"123.45\"\nflottant = float(chaine)  # Convertit la chaîne \"123.45\" en float 123.45\n\n## Depuis un entier** :\nentier = 100\nflottant = float(entier)  # Convertit l'entier 100 en float 100.0\n\n## Depuis un booléen** :\nvrai = True\nflottant = float(vrai)  # Convertit True en 1.0\n\n\n\n\nArithmétique : Addition (+), soustraction (-), multiplication (*), et division (/).\n\nsomme = 10 + 5       # Résultat: 15\ndifference = 10 - 5  # Résultat: 5\nproduit = 10 * 5     # Résultat: 50\nquotient = 10 / 5    # Résultat: 2.0\n\nModulo (%) retourne le reste de la division Puissance (**) élève un nombre à une certaine puissance.\n\nreste = 10 % 3       # Résultat: 1\npuissance = 2 ** 3   # Résultat: 8\npuissance_bis = 2 ^ 3\n\n\n\n\n\nLa concaténation (+) combine des chaînes\nLa répétition **(*)** répète une chaîne un certain nombre de fois.\n\n\nmessage = \"Bonjour\" + \" le monde\"  # Résultat: \"Bonjour le monde\"\necho = \"Ha\" * 3                    # Résultat: \"HaHaHa\"\n\n\n\n\nLes opérateurs d’affectation composés sont des raccourcis qui combinent une opération arithmétique ou binaire avec une affectation.\nEn gros, ils vous permettent d’effectuer une opération sur une variable et de lui réaffecter le résultat en une seule étape.\n\n# Initialisation de x\nx = 5\nprint(x)\n\n5\n\n\n\n# Ajouter et assigner\nx += 2  # x est maintenant 7\nprint(x)\n\n7\n\n\n\n# Soustraire et assigner\nx -= 3  # x est maintenant 4\nprint(x)\n\n4\n\n\n\n# Multiplier et assigner\nx *= 4  # x est maintenant 16\nprint(x)\n\n16\n\n\n\n# Diviser et assigner\nx /= 2  # x est maintenant 8\nprint(x)\n\n8.0\n\n\n\n# Division entière et assigner\nx //= 3  # x est maintenant 2\nprint(x)\n\n2.0\n\n\n\n# Modulo et assigner\nx %= 3  # x est maintenant 2\nprint(x)\n\n2.0\n\n\n\n# Exponentielle et assigner\nx **= 2  # x est maintenant 4\nprint(x)\n\n4.0"
  },
  {
    "objectID": "Fondamentaux.html#commentaires-et-affichage",
    "href": "Fondamentaux.html#commentaires-et-affichage",
    "title": "Les fondamentaux de Python",
    "section": "Commentaires et affichage",
    "text": "Commentaires et affichage\nLes commentaires sont utilisés pour expliquer le code.\nIls sont très utiles pour vous-même et pour les autres personnes qui lisent votre code. Les commentaires commencent par un # et s’étendent jusqu’à la fin de la ligne.\nLes commentaires sont ignorés lors de l’exécution du code.\n\n# Ceci est un commentaire simple \n\nx = 5  # Ceci est un commentaire suivant une instruction\n\n# Vous pouvez utiliser les commentaires pour expliquer\n# ce que votre code est censé faire :\ny = x + 2  # Ajout de 2 à x et stockage du résultat dans y\n\nPour l’affichage, la fonction print() est utilisée. Elle permet d’afficher le texte, les nombres, et d’autres objets sur la console.\n\nprint(\"Bonjour, monde !\")  # Affiche un message simple\n\nnombre = 10\nprint(nombre)  # Affiche la valeur de la variable 'nombre'\n\n# Vous pouvez aussi combiner du texte et des variables :\nprint(\"Le nombre est\", nombre)  # Affiche \"Le nombre est 10\"\n\nBonjour, monde !\n10\nLe nombre est 10\n\n\nUtilisation de f-string\n\nprenom = 'Marie'\nage = 15\ntaille = 207\n\n# Formatage de chaînes avec f-string pour une lisibilité améliorée :\nprint(f\"Marie a {age}\") \nprint(f\"{prenom}, est partie\")\n\nMarie a 15\nMarie, est partie\n\n\nf-string avec Plusieurs Variables\n\nprint(f\"{prenom} mesure {taille} metres et a {age} ans\")\n\nMarie mesure 207 metres et a 15 ans\n\n\nUtilisation de format\n\nprint(\"{} a {} ans \".format(prenom, age))\n\nMarie a 15 ans \n\n\n\nL’instruction précédente utilise la méthode .format() pour insérer les variables dans la chaîne de caractères.\n{} sont des placeholders (espaces réservés) qui seront remplacés par les arguments de .format() dans l’ordre.\nma_chaine et age seront insérés respectivement dans le premier et le second {}.\n\nCalcul et arrondi\n\nLe premier print(prop) affiche la valeur de prop avec tous ses chiffres après la virgule.\nLe second print() utilise une f-string avec un formatage spécifique {prop:.2f}.\n\nCela signifie que la valeur de prop sera formatée pour afficher seulement deux chiffres après la virgule.\n\nprop = 2543276 / 678\nprint(prop)\nprint(f\"le resultat est {prop:.3f}\")\n\n3751.1445427728613\nle resultat est 3751.145"
  },
  {
    "objectID": "Fondamentaux.html#structure-de-contrôle",
    "href": "Fondamentaux.html#structure-de-contrôle",
    "title": "Les fondamentaux de Python",
    "section": "Structure de contrôle",
    "text": "Structure de contrôle\n\nLes opérateurs\nLes opérateurs Python sont utilisés pour effectuer des opérations sur les variables et les valeurs.\n\nLes opérateurs de comparaison incluent égal à, différent de, supérieur à, inférieur à, supérieur ou égal à, et inférieur ou égal à.\n\nRenvoient soit Vrai, soit Faux, en fonction du résultat de la comparaison.\n\n\n\n\n\nOpérateur comparaison\nDescription\n\n\n\n\n\nÉgalité\n==\n\n\n\nDifférent de\n!=\n\n\n\nSupérieur\n&gt;\n\n\n\nInférieur\n&lt;\n\n\n\nSupérieur ou égale\n&gt;=\n\n\n\nInférieur ou égale\n&lt;=\n\n\n\n\n\nLes opérateurs logiques et, ou et non sont souvent combinés avec les opérateurs de comparaison.\n\n\n\n\nOpérateur logique\nDescription\nRésultat\n\n\n\n\nAnd\nand\nTrue si les deux propositions sont vraies\n\n\nOr\nor\nTrue si au moins une des propositions est Vraie\n\n\nNot\nnot\nInverse de l’instruction\n\n\n\n\nLes opérateurs d’appartenance in et not in sont utilisés pour vérifier si une valeur ou une chaîne de caractères se trouve à l’intérieur d’une autre valeur, chaîne de caractères ou séquence.\n\n\n\n\n\n\n\n\n\nOpérateur logique\nDescription\nRésultat\n\n\n\n\nIn\nin\nTrue si la valeur spécifiée est présente dans l’objet\n\n\nNot In\nnot in\nTrue si la valeur spécifiée n’est pas présente dans l’objet\n\n\n\n\n# Exemples d'opérateurs de comparaison\nprint(\"Opérateurs de comparaison:\")\nprint(5 == 5)  # Égalité, renvoie True\nprint(5 != 2)  # Différent de, renvoie True\nprint(5 &gt; 3)   # Supérieur à, renvoie True\nprint(5 &lt; 8)   # Inférieur à, renvoie True\nprint(5 &gt;= 3)  # Supérieur ou égal à, renvoie True\nprint(5 &lt;= 8)  # Inférieur ou égal à, renvoie True\n\nOpérateurs de comparaison:\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n\n# opérateurs logiques \n## and \n(5 &gt; 3) and (10 &lt; 100)\n\nTrue\n\n\n\nnot ((5 &gt; 3) and (10 &gt; 100))\n\nTrue\n\n\n\n## or \n(5 &gt; 3) or (10 &lt; 100)\n(5 &gt; 3) or (10 &gt; 100)\n\nTrue\n\n\n\n# operateurs d'appartenance\n# in et not in \nx = [5, 10, 24] \n10 in x \n10 not in x \n\nFalse\n\n\nChainer les comparateurs Il est également possible de chainer les comparateurs:\n\na, b, c = 1, 10, 100\na &lt; b &lt; c\n\nTrue\n\n\n\na &gt; b &lt; c\n\nFalse\n\n\n\n\nLes conditions\n\n# condition\nx = 40 \n\n# Première condition : vérifie si x est inférieur à 10\nif x &lt; 10:\n    print(\"x est inférieur à 10\")\n\n# Deuxième condition : vérifie si x est supérieur ou égal à 100 \nelif x &gt;= 100:\n    print(\"x est supérieur ou égal à 100\")\n\n# Dernière condition : si toutes les conditions précédentes sont fausses\nelse:\n    print(\"x est supérieur à 10 mais inférieur à 100\")\n\nx est supérieur à 10 mais inférieur à 100\n\n\n\n# Initialisation des variables\nx = 100 \ny = 30 \n\n# Première condition : vérifie si x est inférieur à 10 ET y est supérieur à 20\nif (x &lt; 10) and (y &gt; 20):\n    print(\"x est inférieur à 10 et y est supérieur à 20\")\n\n# Deuxième condition : vérifie si x est supérieur ou égal à 100 OU y est supérieur ou égal à 30\nelif (x &gt;= 100) or (y &gt;= 30):\n    print(\"x est supérieur ou égal à 100 ou y est supérieur ou égal à 30\")\n\n# Dernière condition : si\n#  toutes les conditions précédentes sont fausses\nelse:\n    print(\"x est supérieur à 10\")\n\nx est supérieur ou égal à 100 ou y est supérieur ou égal à 30\n\n\n\n\nLes boucles\nLa boucle for est utilisée pour parcourir des structures de données : liste, tuple, tableau, chaîne de caractères ou un dictionnaire.\n\nLa boucle commence par examiner le premier élément de la séquence, effectue des actions dans son corps, puis passe à l’élément suivant jusqu’à ce que la séquence soit terminée.\n\n\nBoucle avec mot-clé “for”, une variable temporaire pour contenir chaque élément, le mot-clé “in” et la séquence à parcourir, suivis de deux points. Jusqu’au bout de l’élément\n\nAppliquer des opérations sur la variable temporaire dans le corps de la boucle pour effectuer diverses opérations.\nImbriquer des for”\nSur les dictionnaires, on peut boucler sur les clés et les valeurs à l’aide de la méthode “items()”.\n\n\n\nliste = list(range(5))\nliste\n\n[0, 1, 2, 3, 4]\n\n\n\n# Exemple de boucle for\nfor i in liste:\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\nfruits = [\"pomme\", \"banane\", \"mangue\", \"cerise\"]\nfor fruit in fruits:\n    print(fruit)\n\npomme\nbanane\nmangue\ncerise\n\n\n\n# print(\"Boucle for sur une liste:\")\n# ma_liste = [1, 2, 3, 4, 5]\n# for element in ma_liste:\n#     print(element)\n\nnombres = [1, 2, 3, 4, 5]\nfor nombre in nombres:\n    if nombre % 2 == 0:\n        print(f\"{nombre} est pair\")\n    else:\n        print(f\"{nombre} est impair\")\n\n1 est impair\n2 est pair\n3 est impair\n4 est pair\n5 est impair\n\n\nLa boucle while itère sur un bloc de code tant qu’une condition spécifiée est vraie. Contrairement aux boucles “for”, les boucles “while” continuent l’itération tant que la condition reste vraie.\n\n“break” pour quitter prématurément une boucle “while”, même si la condition est toujours vraie.\n“else” peut être utilisée avec une boucle “while” pour spécifier un bloc de code qui s’exécutera lorsque la condition de la boucle ne sera plus vraie.\n“continue” permet d’ignorer le code restant dans l’itération actuelle de la boucle et de passer à l’itération actuelle de la boucle et de passer à l’itération suivante.\n!! Soyez prudent lorsque vous utilisez “continue” afin d’éviter de créer des boucles infinies.\n\n\n# Boucle while avec break\nprint(\"\\nBoucle while avec break:\")\ni = 1\nwhile i &lt;= 5:\n    print(i)\n    if i == 3:\n        print(\"Break à 3\")\n        break\n    i += 1\n\n\nBoucle while avec break:\n1\n2\n3\nBreak à 3\n\n\n\n# Boucle while avec continue\nprint(\"\\nBoucle while avec continue:\")\ni = 0\nwhile i &lt; 5:\n    i += 1\n    if i == 3:\n         continue\n    print(i)\n\n\nBoucle while avec continue:\n1\n2\n4\n5\n\n\n\n# Boucle while avec else\nprint(\"\\nBoucle while avec else:\")\ni = 1\nwhile i &lt;= 5:\n    print(i)\n    i += 1\nelse:\n    print(\"La condition n'est plus vraie (i &gt; 5)\")\n\n\nBoucle while avec else:\n1\n2\n3\n4\n5\nLa condition n'est plus vraie (i &gt; 5)\n\n\n\n# Exemple de boucle while True\nprint(\"Boucle while True avec un mécanisme de sortie :\")\n\ncompteur = 0\nwhile True:\n    compteur += 1\n    print(compteur)\n\n    # Interrompre la boucle si compteur atteint 5\n    if compteur == 5:\n        print(\"Compteur a atteint 5, sortir de la boucle.\")\n        break\n\nBoucle while True avec un mécanisme de sortie :\n1\n2\n3\n4\n5\nCompteur a atteint 5, sortir de la boucle.\n\n\n\nsaisi = 5\nwhile True:  \n    if saisi == 5:\n        print(\"Vous avez saisi la valeur 5\")\n        break\n    else: \n        print(\"Saisissez un autre chiffre: \")\n\nVous avez saisi la valeur 5\n\n\n\nsaisi_mot_de_passe = \"azerty\"\n\nwhile True:  \n    if saisi_mot_de_passe == \"azerty\":\n        print(\"Login success\")\n        break\n    else: \n        print(\"Login fail\")\n        break\n\nLogin success\n\n\n\nimport random \n\nnombre_aleatoire = random.randint(1, 10)\nnombre_aleatoire\n\n9"
  },
  {
    "objectID": "Fondamentaux.html#types-de-données",
    "href": "Fondamentaux.html#types-de-données",
    "title": "Les fondamentaux de Python",
    "section": "Types de données",
    "text": "Types de données\nChaque type de données séquentielles a ses propres caractéristiques et utilisations spécifiques, offrant une grande flexibilité pour le traitement des données. Les listes et les dictionnaires sont particulièrement populaires pour leur flexibilité et leurs capacités de stockage dynamique.\n\nLes chaines de caractères\nLes chaînes de caractères (str) sont utilisées pour stocker et manipuler du texte. Elles sont définies en plaçant le texte entre guillemets simples ('...'), doubles (\"...\") ou triples ('''...''' ou \"\"\"...\"\"\" pour les chaînes sur plusieurs lignes).\n\n\nSéquences de caractères, indexées à partir de 0.\nPeuvent être délimitées par des guillemets simples, doubles ou triples.\nExemple : \"Mareva\", 'Prog'.\nCaractères d’Échappement : pour inclure des caractères spéciaux comme des guillemets ou des retours à la ligne dans une chaîne, utilisez des caractères d’échappement (\\).\n\n\ncitation = \"Elle a dit \\\"Bonjour!\\\"\"\nretour_ligne = \"Ligne 1\\nLigne 2\"\n\nLes chaînes de caractères sont extrêmement polyvalentes et fournissent une gamme complète de méthodes pour le traitement de texte. Que ce soit pour la manipulation de base ou des opérations complexes, les chaînes sont un outil indispensable.\n\n# Définition chaines de caractères\nchaine_simple = 'Bonjour'\nlongueur = len(chaine_simple) # 7\nprint(f\"{chaine_simple}, 'la longueur est {longueur}\")\n\nBonjour, 'la longueur est 7\n\n\n\nchaine_simple[3]\n\n'j'\n\n\n\nchaine_double = \"Python\"\nchaine_multiligne = \"\"\"Ceci est une\nchaîne sur plusieurs\nlignes.\"\"\"\nprint(chaine_double,\"\\n\", chaine_multiligne)\n\n# Acces aux éléments\npremier_char = chaine_simple[0]  # 'B'\nsous_chaine = chaine_double[1:4] # 'yth'\nprint(premier_char, \"et\",  sous_chaine)\n\n# Concaténation \nsalutation = chaine_simple + \", \" + chaine_double # 'Bonjour, Python'\nprint(salutation)\n\n# Répétition\necho = \"echo \" * 3  # 'echo echo echo '\nprint(echo)\n\nPython \n Ceci est une\nchaîne sur plusieurs\nlignes.\nB et yth\nBonjour, Python\necho echo echo \n\n\n\nMéthodes pour les Chaînes de Caractères : Les méthodes sont des fonctions qui sont associées à des objets spécifiques. Elles permettent d’exécuter des actions sur ces objets ou de manipuler leurs données internes. Voici quelques caractéristiques clés des méthodes :\n\nAssociation avec des Objets : Contrairement aux fonctions indépendantes, les méthodes sont liées à des objets. Par exemple, les méthodes de chaînes de caractères (str) sont conçues pour effectuer des opérations sur des chaînes de caractères spécifiques.\nSyntaxe : Une méthode est appelée en utilisant la notation pointée. Par exemple, objet.methode().\nMéthodes de Chaînes de Caractères : les chaînes de caractères disposent de méthodes telles que upper(), lower(), replace() pour convertir en majuscules, en minuscules ou remplacer une partie de la chaîne.\nAppel : Pour appeler une méthode, utilisez généralement la syntaxe objet.methode(arguments).\n\n\n\n# Méthodes str.isupper() et str.islower()\nmajuscules = \"PYTHON\"\nminuscules = \"python\"\n\nis_upper = majuscules.isupper()\nis_lower = minuscules.islower()\nprint(is_upper)  # Résultat : True\nprint(is_lower)  # Résultat : True\n\n# Méthode str.upper()\ntexte_upper = \"python est génial\".upper()\nprint(texte_upper)  # Résultat : \"PYTHON EST GÉNIAL\"\n\n# Méthode str.lower()\ntexte_lower = \"Python est GÉNIAL\".lower()\nprint(texte_lower)  # Résultat : \"python est génial\"\n\n# Méthode str.capitalize()\ntexte_capitalize = \"python est génial\".capitalize()\nprint(texte_capitalize)  # Résultat : \"Python est génial\"\n\n# Méthode str.title()\ntexte_title = \"python est génial\".title()\nprint(texte_title)  # Résultat : \"Python Est Génial\"\n\n# Méthode str.find(substring)\ntexte = \"Python est génial\"\nposition = texte.find(\"est\")\nprint(position)  # Résultat : 7\n\n# Méthode str.replace(old, new)\ntexte_replace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\")\nprint(texte_replace)  # Résultat : \"Les bananes sont rouges.\"\n\n# Méthode str.split(separator)\ntexte_split = \"apple orange banana\".split(\" \")\nprint(texte_split)  # Résultat : [\"apple\", \"orange\", \"banana\"]\n\n# Méthode str.join(iterable)\nelements = [\"apple\", \"orange\", \"banana\"]\ntexte_join = \", \".join(elements)\nprint(texte_join)  # Résultat : \"apple, orange, banana\"\n\n# Méthode str.strip()\ntexte_strip = \"   Bonjour   \".strip()\nprint(texte_strip)  # Résultat : \"Bonjour\"\n\n# Méthode str.startswith(prefix)\ntexte_startswith = \"Bonjour, comment ça va ?\".startswith(\"Bonjour\")\nprint(texte_startswith)  # Résultat : True\n\n# Méthode str.endswith(suffix)\ntexte_endswith = \"Leçon terminée.\".endswith(\"terminée.\")\nprint(texte_endswith)  # Résultat : True\n\nTrue\nTrue\nPYTHON EST GÉNIAL\npython est génial\nPython est génial\nPython Est Génial\n7\nLes bananes sont rouges.\n['apple', 'orange', 'banana']\napple, orange, banana\nBonjour\nTrue\nTrue\n\n\n\n\nLes listes\nLes listes sont des structures de données qui permettent de stocker une série d’éléments. Elles sont flexibles, peuvent contenir des éléments de différents types et sont mutables (modifiables).\n\nListes (list) :\n\nCollections ordonnées de valeurs, pouvant contenir divers types de données.\nLes éléments sont séparés par des virgules et entourés de crochets.\nMutables (modifiables).\nPour créer une liste, placez une série d’éléments séparés par des virgules entre crochets []. Exemple : [1, \"a\", 3.14].\nL’accès aux éléments se fait par leur index, en commençant par 0.\nLes listes étant mutables, vous pouvez modifier leurs éléments.\n\n\n\n# Définition de liste\nma_liste = [1, 2, 3, \"Python\", 3.14, True]\nprint(ma_liste)\n\npremier_element = ma_liste[0]  # Accède au premier élément (1)\ndernier_element = ma_liste[-1] # Accède au dernier élément (True)\nprint(premier_element,\"\\n\", dernier_element)\n\n # Modifie le deuxième élément\nma_liste[1] = \"deux\" \nprint(ma_liste)\n\n# Concaténation et Répétition\ncombinee = ma_liste + [\"autre\", \"liste\"]\nprint(combinee)\nrepetee = [1, 2, 3] * 3\nprint(repetee)\n\n[1, 2, 3, 'Python', 3.14, True]\n1 \n True\n[1, 'deux', 3, 'Python', 3.14, True]\n[1, 'deux', 3, 'Python', 3.14, True, 'autre', 'liste']\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\nLe Slicing : En plus d’accéder aux éléments d’une chaine un par un, Python fournit une syntaxe concise pour accéder aux sous-listes; cela est connu sous le nom de slicing :\n\n\nnums = list(range(5)) # range est une fonction intégrée qui crée une liste d'entiers\nnums                  # Renvoie \"[0, 1, 2, 3, 4]\"\nnums[2:4]             # Obtenir une tranche de l'index 2 à 4 (exclusif); renvoie \"[2, 3]\"\nnums[2:]              # Obtenir une tranche de l'index 2 jusqu'à la fin; renvoie \"[2, 3, 4]\"\nnums[:2]              # Obtenir une tranche du début jusqu'à l'index 2 (exclusif); renvoie \"[0, 1]\"\nnums[:]               # Obtenir une tranche de toute la liste; renvoie \"[0, 1, 2, 3, 4]\"\nnums[:-1]             # Les indices de tranche peuvent être négatifs; renvoie \"[0, 1, 2, 3]\"\nnums[::-1]            # Les indices de tranche peuvent être négatifs pour inverser l'ordre ; renvoie \"[4, 3, 2, 1, 0]\"\n\n[4, 3, 2, 1, 0]\n\n\nAttribuer à une tranche (même avec une source de longueur différente) est possible car les listes sont mutables :\n\n# Cas 1: source de même longueur\nnums1 = [1, 2, 3]\nnums1[1:] = [4, 5]     # Assigner une nouvelle sous-liste à une tranche\nnums1                  # Renvoie \"[1, 4, 5]\"\n\n# Cas 2: source de longueur différente\nnums2 = nums1\nnums2[1:] = [6]        # Assigner une nouvelle sous-liste à une tranche\nnums2                  # Renvoie \"[1, 6]\"\nid(nums1) == id(nums2) # Renvoie True car les listes sont mutables, c'est-à-dire qu'elles peuvent être modifiées sur place\n\nTrue\n\n\nSimilaire aux tuples, lors de l’évaluation d’une plage sur les indices de liste (quelque chose de la forme [x:y] où x et y sont des indices dans la liste), si notre valeur de droite dépasse la longueur de la liste, Python renvoie simplement les éléments de la liste jusqu’à ce que la valeur dépasse la plage d’index.\n\na = [1, 2, 3] # Index maximal adressable: 2\na[:3]         # NE renvoie PAS d'erreur, renvoie plutôt [1, 2, 3]\n\n[1, 2, 3]\n\n\n\nLes méthodes des listes : Chaque méthode offre une fonctionnalité unique pour manipuler des listes, rendant ces structures de données extrêmement flexibles et puissantes pour une variété de tâches en programmation Python.\n\n\n\n\n\n\n\n\n\nMéthode\nDescription\nExemple\n\n\n\n\nappend()\nAjoute un élément à la fin de la liste\nlist.append(8)\n\n\nextend()\nÉtend la liste en ajoutant tous les éléments d’une autre liste\nlist.extend([9, 12])\n\n\ninsert()\nInsère un élément à une position donnée\nliste.insert(4, d)\n\n\nremove()\nSupprime la première occurrence d’un élément\nliste.remove('d')\n\n\npop()\nSupprime et renvoie un élément à une position donnée (par défaut ,le dernier)\nliste.pop()\n\n\nclear()\nSupprime tous les éléments de la liste\nliste.clear()\n\n\nindex()\nRetourne l’indice du premier élément correspondant\nliste.index('d')\n\n\ncount()\nCompte le nombre d’occurences d’une élément spécifique\nliste.count(8)\n\n\nsort()\nTrie les élément de la liste (dans un ordre spécifique)\nliste.sort()\n\n\nreverse()\nInverse l’ordre des éléments de la liste\nliste.reverse()\n\n\n\n\n# Création d'une liste de base\nma_liste = [1, 2, 3]\nprint(ma_liste)\n\n[1, 2, 3]\n\n\n\n# Utilisation de append()\nma_liste.append(\"quatre\")\nprint(\"Après append(quatre):\", ma_liste)\n# Utilisation de extend()\nma_liste.extend([5, 6])\nprint(\"Après extend([5, 6]):\", ma_liste)\n# Utilisation de insert()\nma_liste.insert(1, 'elephant')\nprint(\"Après insert(1, 'elephant'):\", ma_liste)\n# Utilisation de remove()\nma_liste.remove('elephant')\nprint(\"Après remove('elephant'):\", ma_liste)\n# Utilisation de pop()\nelement_supprime = ma_liste.pop()\nprint(\"Après pop():\", ma_liste, \", Élément supprimé:\", element_supprime)\n# Utilisation de clear()\nma_liste.clear()\nprint(\"Après clear():\", ma_liste)\n\nAprès append(quatre): [1, 2, 3, 'quatre']\nAprès extend([5, 6]): [1, 2, 3, 'quatre', 5, 6]\nAprès insert(1, 'elephant'): [1, 'elephant', 2, 3, 'quatre', 5, 6]\nAprès remove('elephant'): [1, 2, 3, 'quatre', 5, 6]\nAprès pop(): [1, 2, 3, 'quatre', 5] , Élément supprimé: 6\nAprès clear(): []\n\n\n\n# Recréation de la liste pour les autres méthodes\nma_liste = [3, 1, 4, 2, 2]\n\n\n# Utilisation de index()\nindex_de_4 = ma_liste.index(4)\nprint(\"Index de 4:\", index_de_4)\n\n# Utilisation de count()\ncompte_de_2 = ma_liste.count(2)\nprint(\"Nombre d'occurrences de 2:\", compte_de_2)\n\n# Utilisation de sort()\nma_liste.sort()\nprint(\"Après sort():\", ma_liste)\n\n# Utilisation de reverse()\nma_liste.reverse()\nprint(\"Après reverse():\", ma_liste)\n\nIndex de 4: 2\nNombre d'occurrences de 2: 2\nAprès sort(): [1, 2, 2, 3, 4]\nAprès reverse(): [4, 3, 2, 2, 1]\n\n\n\nParcours de Liste Le parcours de liste consiste à accéder séquentiellement à chaque élément d’une liste. Cela peut être fait de différentes manières, mais les plus courantes sont les boucles for et while.\n\nBoucle for : La boucle for est la méthode la plus couramment utilisée pour parcourir une liste. Elle permet de traiter chaque élément individuellement.\nList Comprehension : La compréhension de liste est une méthode concise pour créer des listes. Elle permet de transformer une liste en une autre liste, en filtrant les éléments pour former une liste des résultats d’une expression donnée.\n\n\nLa syntaxe de base d’une compréhension de liste est :\n[nouvelle_expression for item in iterable if condition]\n\nnouvelle_expression est l’expression qui définit comment mapper les éléments de l’iterable (par exemple, une liste).\nitem est la variable qui prend la valeur de chaque élément de l’iterable pendant chaque itération.\ncondition est une condition optionnelle pour filtrer les éléments de l’iterable.\n\n\n# récupérer tous les fruits avec un \"a\"\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\nnewlist = []\n\nfor f in fruits:\n    if \"a\" in f:\n        newlist.append(f)\n\nprint(newlist)\n\n['apple', 'banana', 'mango']\n\n\n\nnewlist = [f for f in fruits if \"a\" in f ]\nprint(newlist)\n\n['apple', 'banana', 'mango']\n\n\n\nnombre = [1, 10, 100]\nnombre_carres = [x**2 for x in nombre]\nnombre_carres\n\n[1, 100, 10000]\n\n\n\n# Créer une liste des carrés des nombres de 0 à 9 :\ncarres = [x**2 for x in range(10)]\n\n\n# Filtrer les nombres pairs dans une liste :\nnombres_pairs = [x for x in range(10) if x % 2 == 0]\n\n\n# Appliquer une fonction à tous les éléments :\nnoms_majuscules = [nom.upper() for nom in [\"alice\", \"bob\", \"charlie\"]]\nnoms_majuscules\n\n['ALICE', 'BOB', 'CHARLIE']\n\n\nD’autre part, les compréhensions de liste peuvent être écrites de manière équivalente en utilisant une combinaison du constructeur de liste, et/ou map et/ou filter :\n\nlist(map(lambda x: x + 10, [1, 2, 3]))          # Retourne [11, 12, 13]\nlist(map(max, [1, 2, 3], [4, 2, 1]))            # Retourne [4, 2, 3]\nlist(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]))  # Retourne [6, 7]\n\n[6, 7]\n\n\nAvec des boucles imbriquées\nVoici une boucle for qui aplatit une matrice (une liste de listes) :\n\n# Définition de la matrice\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]]\n\n\nflattened = []\nfor row in matrix:\n    for n in row:\n        flattened.append(n)\n\nEt voici une compréhension de liste qui fait la même chose :\n\nflattened = [n for row in matrix for n in row]\n\nLes boucles imbriquées dans les compréhensions de liste ne se lisent pas comme du texte. Une erreur commune est de lire cette compréhension de liste comme suit :\n\nflattened = [n for n in row for row in matrix]\n\nMais ce n’est pas correct ! Nous avons inversé les boucles for ici par erreur. La version correcte est celle ci-dessus. Lorsque vous travaillez avec des boucles imbriquées dans les compréhensions de liste, rappelez-vous que les clauses for restent dans le même ordre que dans nos boucles for originales.\n\n\nLes tuples\nLes tuples sont :\n\nSimilaires aux listes, mais immuables (non modifiables après création).\nLes éléments sont séparés par des virgules et entourés de parenthèses.\nExemple : (1, “a”, 3.14).\n\n\n\n\n\n\n\n\n\nAvantage\nDescription\n\n\n\n\n\nSécurité des données\nParfait pour protéger les données contre les modifications\n\n\n\nPerformance\nPlus rapide à parcourir que les listes\n\n\n\nutilisation en tant queClé de Dictionnaire\nPeuvent être utilisés comme clés dans les dictionnaires, contrairement aux listes\n\n\n\nRetour de plusieurs valeurs de fonction\nUtilisé pour retourner plusieurs valeurs depuis une fonction\n\n\n\nStockage de données constantes\nIdéaux pour stocker des données qui ne doivent pas être modifiées\n\n\n\n\n\n# Définition d'un tuple\nmon_tuple = (1, \"a\", 3.14)\nmon_tuple\n\n(1, 'a', 3.14)\n\n\n\nun_autre_tuple = 2, \"b\", 4.28\nun_autre_tuple\n\n(2, 'b', 4.28)\n\n\n\nmon_tuple[1] \n\n'a'\n\n\n\n# Tuple à Un Élément\ntuple_singleton = 5,\ntuple_singleton\n\n(5,)\n\n\n\n# Tuple à Un Élément\ntuple_singleton = (5,)\n\n# Imbrication\ntuple_imbrique = (1, (2, 3), (4, 5))\n\n# Méthodes Utiles\n\n\nlongueur = len(mon_tuple)  # Retourne la longueur de mon_tuple, ici 3\nlongueur\n\n3\n\n\n\ncompteur = mon_tuple.count(\"a\")  # Compte le nombre de fois que 1 apparaît dans mon_tuple, ici 1\ncompteur\n\n1\n\n\n\nindice = mon_tuple.index(\"a\")  # Trouve l'indice de \"a\" dans mon_tuple, ici 1\nindice\n\n1\n\n\n\n# L'affectation n'est pas possible\n# mon_tuple[1] = \"b\"\n\n\n\nLes ensembles\nLes ensembles sont :\nCollections non ordonnées de valeurs uniques. Utiles pour les opérations d’ensemble et la recherche de valeurs uniques. Mutables, mais chaque élément doit être unique. Non-Ordonnés : Les ensembles ne maintiennent pas l’ordre des éléments. Vous ne pouvez donc pas accéder aux éléments par un index. Exemple : {1, 2, 3}.\nOpérations d’Ensemble\n\n\n\n\n\n\n\n\nOpération\nSyntaxe\nDescription\n\n\n\n\nUnion\na | b\nRetourne un nouvel ensemble contenant tous les éléments uniques des ensembles a et b\n\n\nIntersection\na & b\nRetourne un nouvel ensemble contenant uniquement les éléments communs aux ensembles a et b\n\n\nDifférence\na - b\nRetourne un nouvel ensemble contenant les éléments de a qui ne sont pas dans b\n\n\nDifférence symétrique\na ^ b\nRetourne un nouvel ensemble contenant tous les éléments qui sont dans a ou b, mais pas dans les deux\n\n\nAjout\na.add(x)\nAjoute l’élément x à l’ensemble a\n\n\nSuppression\na.remove(x)\nSupprime l’élément x de l’ensemble a ; lève une erreur si x n’est pas présent\n\n\nSuppression (sans erreur)\na.discard(x)\nSupprime l’élément x de l’ensemble a si x est présent ; ne fait rien sinon\n\n\n\n\n# Définition des ensembles\nensemble_a = {1, 2, 3, 4}\nensemble_b = {3, 4, 5, 6}\nprint(ensemble_a, ensemble_b)\n\n# Seule une valeur est représentée\nensemble_c = {1, 1, 1}\nprint(ensemble_c)\n\n{1, 2, 3, 4} {3, 4, 5, 6}\n{1}\n\n\n\n# Opérations d'ensemble\nunion = ensemble_a | ensemble_b\nintersection = ensemble_a & ensemble_b\ndifference_a = ensemble_a - ensemble_b\ndifference_b = ensemble_b - ensemble_a\ndifference_symetrique = ensemble_a ^ ensemble_b\n\n# Affichage des résultats\nprint(\"Union :\", union)\nprint(\"Intersection :\", intersection)\nprint(\"Différence a :\", difference_a)\nprint(\"Différence b :\", difference_b)\nprint(\"Différence Symétrique :\", difference_symetrique)\nprint(ensemble_a)\n\nUnion : {1, 2, 3, 4, 5, 6}\nIntersection : {3, 4}\nDifférence a : {1, 2}\nDifférence b : {5, 6}\nDifférence Symétrique : {1, 2, 5, 6}\n{1, 2, 3, 4}\n\n\n\n# Ajout et suppression\nensemble_a.add(7)\nprint(\"Après ajout :\", ensemble_a)\n\nAprès ajout : {1, 2, 3, 4, 7}\n\n\n\nensemble_a.remove(1)\nprint(\"Après suppression :\", ensemble_a)\n\nAprès suppression : {2, 3, 4, 7}\n\n\n\nensemble_a.discard(2)  \nensemble_a\n\n{3, 4, 7}\n\n\n\n\nLes dictionnaires\nLes dictionnaires sont :\n\nBasés sur des paires clé-valeur.\nLes valeurs sont accessibles via les clés.\nMutables, permettant les mises à jour et les suppressions.\nExemple : {“nom”: “Alice”, “âge”: 30}.\nUtilisation :\n\nStockage d’Informations Structurées : Parfait pour stocker des informations complexes comme des données utilisateur.\nRecherche Rapide : Utilisez des dictionnaires pour des recherches rapides basées sur des clés uniques.\n\n\n\n# Définition d'un dictionnaire\npersonne = {\"nom\": \"Alice\", \"age\": 30}\nautre_dict = dict(nom=\"Bob\", age=25)\n\n\npersonne\n\n{'nom': 'Alice', 'age': 30}\n\n\n\n# Ajout et Mise à Jour\npersonne[\"profession\"] = \"Développeur\"\npersonne\n\n{'nom': 'Alice', 'age': 30, 'profession': 'Développeur'}\n\n\n\n# Mise à Jour de plusieurs clés\npersonne.update([('nom', \"Romain\"), ('profession', \"Data Scientist\")])\npersonne\n\n{'nom': 'Romain', 'age': 30, 'profession': 'Data Scientist'}\n\n\n\n# Utilisation de keys()\ncles = personne.keys()\nprint(\"Clés:\", cles)\n\n# Utilisation de values()\nvaleurs = personne.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = personne.items()\nprint(\"Paires clé-valeur:\", paires)\n\nClés: dict_keys(['nom', 'age', 'profession'])\nValeurs: dict_values(['Romain', 30, 'Data Scientist'])\nPaires clé-valeur: dict_items([('nom', 'Romain'), ('age', 30), ('profession', 'Data Scientist')])\n\n\n\n# Utilisation de get()\nnom_personne = personne.get(\"nom\") \nage_personne = personne.get(\"age\")\n\nnom_personne, age_personne\n\n('Romain', 30)\n\n\n\nville = personne.get(\"ville\")\nville\n\n\nville = personne.get(\"ville\", \"Non spécifiée\")  # Retourne 'Non spécifiée' car 'ville' n'existe pas\nprint(\"Ville:\", ville)\n\nVille: Non spécifiée\n\n\n\n# Parcours des clés\nprint(\"\\nParcours des clés:\")\nfor cle in personne.keys():\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in personne.values():\n    print(valeur)\n\n# Parcours des paires clé-valeur\nprint(\"\\nParcours des paires clé-valeur:\")\nfor cle, valeur in personne.items():\n    print(cle, \":\", valeur)\n\n\nParcours des clés:\nnom\nage\nprofession\n\nParcours des valeurs:\nRomain\n30\nData Scientist\n\nParcours des paires clé-valeur:\nnom : Romain\nage : 30\nprofession : Data Scientist\n\n\n\nprint(\"\\nParcours des paires clé-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(personne.items()):\n    print(f\"Index {index}: Clé = {cle}, Valeur = {valeur}\")\n\n\nParcours des paires clé-valeur avec enumerate:\nIndex 0: Clé = nom, Valeur = Romain\nIndex 1: Clé = age, Valeur = 30\nIndex 2: Clé = profession, Valeur = Data Scientist\n\n\n\npersonne\n\n{'nom': 'Romain', 'age': 30, 'profession': 'Data Scientist'}\n\n\n\n# Suppression\ndel personne[\"age\"]\n\n\npersonne\n\n{'nom': 'Romain', 'profession': 'Data Scientist'}\n\n\n\nprofession = personne.pop(\"profession\")\n\n\nprofession\n\n'Data Scientist'\n\n\n\npersonne\n\n{'nom': 'Romain'}\n\n\nDictionary Comprehensions\nCes dernières sont similaires aux compréhensions de listes, mais vous permettent de construire facilement des dictionnaires.\nPar exemple, considérez une boucle for qui crée un nouveau dictionnaire en échangeant les clés et les valeurs de l’original :\n\nflipped = {}\noriginal = {\"a\": 0, \"b\": 5, \"c\": 6, \"d\": 7, \"e\": 11, \"f\": 19}\nfor key, value in original.items():\n    flipped[value] = key\n\nflipped\n\n{0: 'a', 5: 'b', 6: 'c', 7: 'd', 11: 'e', 19: 'f'}\n\n\nLe même code écrit sous forme d’une Dictionary Comprehensions :\n\nflipped = {value: key for key, value in original.items()}\n\nAutre exemple :\n\nnums = [0, 1, 2, 3, 4]\neven_num_to_square = {x: x ** 2 for x in nums if x % 2 == 0}\nprint(even_num_to_square) \n\n{0: 0, 2: 4, 4: 16}"
  },
  {
    "objectID": "Fondamentaux.html#fonctions-définition-et-rappel",
    "href": "Fondamentaux.html#fonctions-définition-et-rappel",
    "title": "Les fondamentaux de Python",
    "section": "Fonctions : définition et rappel",
    "text": "Fonctions : définition et rappel\nQu’est-ce qu’une Fonction ? Une fonction est une suite d’instructions que l’on peut appeler avec un nom. En programmation, une fonction est comme une petite “machine” qui prend des entrées (arguments), effectue certaines opérations, et parfois retourne une sortie (valeur de retour).\n\nExplication de ce qu’est une fonction en programmation , une fonction est définie en utilisant le mot-clé def, suivi du nom de la fonction, des parenthèses () contenant des paramètres (si nécessaires), et un bloc d’instructions indenté.\nL’importance des fonctions pour réduire la répétition de code Les fonctions sont essentielles pour éviter la répétition de code. Au lieu d’écrire le même code plusieurs fois, une fonction nous permet de regrouper ce code et de l’appeler quand nécessaire. Cela rend le code plus court, plus lisible et plus facile à maintenir.\n\nPourquoi Utiliser des Fonctions ? Les fonctions sont un outil fondamental pour plusieurs raisons :\n\nSimplification du code En regroupant des opérations complexes en fonctions, on simplifie notre code principal. Cela le rend plus lisible et plus facile à comprendre.\nRéutilisabilité Une fois que vous avez écrit une fonction, vous pouvez l’utiliser autant de fois que nécessaire. Cela élimine le besoin de réécrire le même code, économisant du temps et réduisant les erreurs.\nMeilleure organisation du code Les fonctions aident à structurer le code en unités logiques. Chaque fonction a un objectif spécifique, ce qui facilite la compréhension du programme dans son ensemble. De plus, cela facilite le débogage et le test de parties spécifiques du code.\n\nVoici le développement de la section “Syntaxe de Base des Fonctions” avec des explications et des exemples, rédigé en Markdown :\nDéfinition d’une Fonction , la définition d’une fonction commence par le mot-clé def, suivi du nom de la fonction, des parenthèses (), et d’un bloc d’instructions indenté.\n\ndef ma_fonction():\n    print(\"Ceci est une fonction.\")\n\nDans cet exemple, ma_fonction est le nom de notre fonction. Le bloc d’instructions qui suit définit ce que la fonction fait lorsqu’elle est appelée. Ici, la fonction affiche simplement un message.\nLa définition d’une fonction permet de regrouper un ensemble d’instructions que vous souhaitez exécuter à plusieurs reprises. Elle n’est exécutée que lorsque la fonction est appelée.\n\nStructure de base La structure de base d’une fonction comprend :\n\nLe mot-clé def. Le nom de la fonction. Les parenthèses () (avec des paramètres si nécessaire). Un bloc d’instructions indenté.\n\nAppel d’une Fonction\n\nUne fois qu’une fonction est définie, elle peut être appelée en utilisant son nom suivi de parenthèses.\n\nma_fonction()\n\nCeci est une fonction.\n\n\nCet appel exécute les instructions définies dans ma_fonction.\n\nParamètres et Arguments Les fonctions peuvent être plus flexibles lorsqu’elles prennent des paramètres. Les paramètres agissent comme des variables dans la définition de la fonction.\n\n\ndef ma_fonction(param1, param2):\n    print(f\"Paramètre 1 : {param1}, Paramètre 2 : {param2}\")\ndef saluer(nom):\n    print(f\"Bonjour, {nom}!\")\n\nIci, nom est un paramètre de la fonction saluer. Lorsque la fonction est appelée, elle s’attend à recevoir une valeur pour ce paramètre.\n\nAppel d’une Fonction avec Arguments Lorsque vous appelez une fonction qui a des paramètres, vous devez fournir des arguments correspondants.\n\nsaluer(“Alice”) Dans cet appel, \"Alice\" est un argument qui est passé à la fonction saluer. La fonction utilisera la valeur de cet argument lors de son exécution.\nExemples :\n\ndef saluer(nom):\n    print(f\"Bonjour, {nom}!\")\n\n\nsaluer(nom = \"Paul\")\nsaluer(nom = \"Ményssa\")\nsaluer(nom = \"Kévin\")\nsaluer(nom = \"Axel\")\n\nBonjour, Paul!\nBonjour, Ményssa!\nBonjour, Kévin!\nBonjour, Axel!\n\n\n\ndef affiche_message(message):\n    print(f\"Message reçu : {message}\")\n\naffiche_message(\"Bonjour, ca  va ?\")\naffiche_message(\"Python c'est cool!\")\n\nMessage reçu : Bonjour, ca  va ?\nMessage reçu : Python c'est cool!\n\n\n\ndef additionner(a, b):\n    somme = a + b\n    print(f\"La somme de {a} et {b} est {somme}\")\n\n\nadditionner(a = 5, b = 3)\nadditionner(5, 3)\n\nLa somme de 5 et 3 est 8\nLa somme de 5 et 3 est 8\n\n\n\nadditionner(b = 10, a = 67)\n\nLa somme de 67 et 10 est 77\n\n\n\ndef division(a, b):\n    quotient = a / b\n    print(f\"Le quotient de {a} et {b} est {quotient}\")\n\n\ndivision(a = 5, b = 3)\ndivision(b = 3, a = 5)\n\ndivision(3, 5)\ndivision(5, 3)\n\nLe quotient de 5 et 3 est 1.6666666666666667\nLe quotient de 5 et 3 est 1.6666666666666667\nLe quotient de 3 et 5 est 0.6\nLe quotient de 5 et 3 est 1.6666666666666667\n\n\n\ndef puissance(base, exposant):\n    resultat = base ** exposant\n    print(f\"{base} élevé à la puissance {exposant} est égal {resultat}\")\n    \npuissance(exposant = 2, base =  3)\n\n3 élevé à la puissance 2 est égal 9\n\n\n\nLes paramètres et arguments\nLes paramètres de fonction sont des variables spécifiées dans la définition d’une fonction. Ils agissent comme des placeholders pour les valeurs (arguments) que la fonction recevra lorsqu’elle est appelée.\nDifférence entre Paramètres et Arguments\n\nParamètres sont les noms donnés aux variables dans la définition de la fonction. Ils sont utilisés dans la fonction pour se référer aux valeurs qui seront passées lors de l’appel de la fonction.\nArguments sont les valeurs réelles passées à la fonction lorsqu’elle est appelée. Ces valeurs sont affectées aux paramètres correspondants de la fonction.\n\nValeurs par Défaut des Paramètres Les fonctions peuvent avoir des paramètres avec des valeurs par défaut. Ces valeurs sont utilisées si aucun argument correspondant n’est fourni lors de l’appel de la fonction.\n\ndef ma_fonction(param1, param2=42):\n    print(f\"Paramètre 1 : {param1}, Paramètre 2 : {param2}\")\n\nDans cet exemple, param2 a une valeur par défaut de 42. Si ma_fonction est appelée sans un second argument, param2 utilisera cette valeur par défaut.\nLes valeurs par défaut rendent les fonctions plus flexibles et permettent d’éviter des erreurs si certains arguments ne sont pas essentiels. Voici un exemple d’appel de la fonction avec et sans le second argument :\n\nma_fonction(\"test\")         # Utilise la valeur par défaut pour param2\nma_fonction(\"test\", 24)     # Remplace la valeur par défaut de param2\ndef ma_fonction(param1, param2=42):\n    print(f\"Paramètre 1 : {param1}, Paramètre 2 : {param2}\")\n\nParamètre 1 : test, Paramètre 2 : 42\nParamètre 1 : test, Paramètre 2 : 24\n\n\n\nma_fonction(2)\n\nParamètre 1 : 2, Paramètre 2 : 42\n\n\n\nma_fonction(2, 30)\n\nParamètre 1 : 2, Paramètre 2 : 30\n\n\n\n\nLes types de fonctions\nIl existe deux types principaux de fonctions : celles qui retournent une valeur et celles qui ne retournent rien.\n\nFonctions avec Retour : Une fonction avec retour renvoie une valeur à l’endroit où elle est appelée. Ce retour est effectué en utilisant le mot-clé return.\nFonctions sans Retour: Les fonctions sans retour effectuent des actions mais ne renvoient aucune valeur. Elles sont souvent utilisées pour effectuer une tâche, comme afficher un message ou modifier des données.\n\n\ndef ma_fonction():\n    return \"valeur retournée\"\n\nCette fonction retourne la chaîne de caractères \"valeur retournée\". Lorsqu’elle est appelée, on peut récupérer cette valeur :\n\nresultat = ma_fonction()\nprint(resultat)  # Affiche \"valeur retournée\"\ndef ma_fonction():\n    print(\"Fonction exécutée\")\n\nvaleur retournée\n\n\nCette fonction affiche un message mais ne retourne rien. L’appel de cette fonction se concentre sur l’effet produit (ici, l’affichage) plutôt que sur une valeur retournée.\n\ndef divison_par_deux(a, b = 2):\n    print( a / b )\n\nresultat = divison_par_deux(5)\nprint(resultat)\n\n2.5\nNone\n\n\n\ndef divison_par_deux(a, b = 2):\n    return a / b\n\nresultat = divison_par_deux(5)\nprint(resultat)\n\n2.5\n\n\n\ndef carre(nombre):\n    return nombre * nombre\n\nresultat = carre(4)\nprint(resultat)  # Affichera 16\n\n\ndef celsius_en_fahrenheit(celsius):\n    return (celsius * 9/5) + 32\n\ntemperature_fahrenheit = celsius_en_fahrenheit(0)\nprint(temperature_fahrenheit)  # Affichera 32\n\ndef est_pair(nombre):\n    return nombre % 2 == 0\n\nresultat = est_pair(10)\nprint(resultat)  # Affichera True\n\ndef maximum(a, b):\n    if a &gt; b:\n        return a\n    else:\n        return b\n\n16\n32.0\nTrue\n\n\n\nmax_nombre = maximum(10, 20)\nprint(max_nombre)  # Affichera 20\n\n20\n\n\n\n\nLa portée des variables\nLa portée d’une variable détermine où dans le code elle est accessible. En Python, les variables peuvent avoir une portée locale ou globale.\n\nx = \"global\"  # Variable globale\nx\n\n'global'\n\n\n\ndef ma_fonction():\n    x = \"local\"  # Variable locale\n    print(x)\n\nma_fonction()\nx\n\nlocal\n\n\n'global'\n\n\nLes variables globales sont utiles pour partager des données entre différentes parties d’un programme.\nCependant, il faut les utiliser avec prudence pour éviter des problèmes de conception.\n\n# le mot-clé `global` est utilisé pour modifier la variable globale\n#  `z` à l'intérieur de la fonction `modifier_globale`.\n\nz = 10\n\ndef modifier_globale():\n    global z\n    z = 20\n\nprint(z)  # Affiche 10\nmodifier_globale()\nprint(z)  # Affiche 20\n\n10\n20\n\n\n\n# Les arguments mot-clé permettent de passer des arguments\n#  à une fonction en spécifiant le nom du paramètre.\ndef ma_fonction(nom, age):\n    print(f\"Nom : {nom}, Âge : {age}\")\n\nma_fonction(age=25, nom=\"Alice\")\n\nNom : Alice, Âge : 25\n\n\n\n\nNombre variable d’arguments\nVous pouvez créer des fonctions qui acceptent un nombre variable d’arguments grâce à *args pour les listes et **kwargs pour les dictionnaires de mots-clés.\n\ndef multiplication(a, b, c=None, d=None, e=None, f=None):\n    return a * b\n\nmultiplication(2, 3)\n\n6\n\n\n\nimport numpy as np\n# arguments arbitraire on ne connait pas le nombre de parametre à l'avance\ndef multiplication(*nombre):\n    res = np.prod(nombre)\n    return res\n\n\nmultiplication(4, 3, 4, 90)\n\n4320\n\n\n\ndef multiplication(*nombre):\n    print(nombre[0]*nombre[1]*nombre[2]*nombre[3])\n\n\nmultiplication(4, 3, 4, 90)\ndef param_args(*parametres):\n    print(parametres[0]*parametres[1])\n    print(f\"Message : {parametres[2]}\")\n    \nparam_args(2, 3, \"Salut!\")\n\n4320\n6\nMessage : Salut!\n\n\n\ndef nombre_args(*args):\n    return len(args)\nargs_tuple = (5, 6, 8, 9)\nnombre_args(*args_tuple) # mettre etoile pour le tuple\n\n4\n\n\n\n# pratique pour définir des clé d'arguments\ndef nombre_kwarg(**nombre):\n    print('Mon age est : ' + nombre['age'] + ' ans' + ' et ma taille est : ' + nombre[\"taille\"] + ' metres')\n\nnombre_kwarg(age  = '15', taille = '1.65', profession = \" Dev\")\n\nMon age est : 15 ans et ma taille est : 1.65 metres\n\n\n\n# `args` est un tuple contenant tous les arguments positionnels\n# `kwargs` est un dictionnaire contenant tous les arguments nommés.\n\ndef ma_fonction(*args, **kwargs):\n    print(\"args:\", args)\n    print(\"kwargs:\", kwargs)\n\nma_fonction(1, 2, 3, nom=\"Alice\", age=25)\n\nargs: (1, 2, 3)\nkwargs: {'nom': 'Alice', 'age': 25}\n\n\n\nBonnes Pratiques Nommer clairement vos fonctions est crucial pour la lisibilité et la maintenabilité de votre code. Les noms de fonctions doivent être descriptifs et refléter ce qu’ils font.\n\nUtilisez des noms descriptifs.\nPrivilégiez les verbes pour les fonctions effectuant des actions.\nÉvitez les abréviations non évidentes. Documenter vos fonctions avec des docstrings, aide d’autres programmeurs (et vous-même dans le futur) à comprendre rapidement ce que fait votre fonction.\n\n\n\ndef ma_fonction():\n    \"\"\"\n    Description de ce que fait la fonction.\n    Peut inclure des détails sur les paramètres et la valeur de retour.\n    \"\"\"\n    # corps de la fonction\n\nLes docstrings sont placées juste sous la définition de la fonction et sont entourées de triples guillemets.\n\n# fonction qui renvoie un nombre à la puissance\ndef nombre_puissance(nombre, puissance): \n    # documenter le code\n    \"\"\"\n    cette fonction calcule un nombre à la puissance et retourne le résultat.    \n    Parameters:    \n    nombre    (int): le premier nombre \n    puissance (int): le deuxième nombre    \n    Returns   (int): le resultat nombre a la puissance     \n    \n    \"\"\"\n    return nombre ** puissance\n\n\nIntéraction avec un utilisateur\nnum = int(input(“Saississez un nombre entier :”)) power = int(input(“Saississez une puissance :”))\nprint(“Le résultat est :”, nombre_puissance(nombre = num, puissance = power))\n\n\n\nLes fonctions anonymes : lambda\nEn Python, le mot-clé lambda est utilisé pour définir des fonctions anonymes, également appelées fonctions lambda.\nLes fonctions lambda sont des fonctions qui ne sont pas définies avec un nom, mais qui peuvent être utilisées dans des expressions ou des fonctions.\nElles sont souvent utilisées dans des situations où une fonction simple est nécessaire pour une tâche spécifique, comme trier une liste ou filtrer des éléments.\n\nc_to_f = lambda x: (x * 9/5) + 32 \nc_to_f(0)\n\n32.0\n\n\n\npeople = [{'name': 'Alice', 'age': 25}, \n          {'name': 'Bob', 'age': 30}, \n          {'name': 'Charlie', 'age': 20}]\nsorted(people, key=lambda x: x['age'])\n\n[{'name': 'Charlie', 'age': 20},\n {'name': 'Alice', 'age': 25},\n {'name': 'Bob', 'age': 30}]\n\n\n\nma_liste = ['abcd', 'abc', 'a', 'ab', 'abcde']\nsorted(ma_liste, key=lambda x: len(x))\n\n['a', 'ab', 'abc', 'abcd', 'abcde']\n\n\n\ncarre  = lambda x: x**2\nliste_carre = [carre(nombre) for nombre in [5, 9, 10]]\nliste_carre\n\nliste_carre = [(lambda x: x**2)(nombre) for nombre in [5, 9, 10]]\nliste_carre\n\n[25, 81, 100]\n\n\n\npersonnes = [\n  {\"nom\": \"Alice\", \"age\": 25},\n  {\"nom\": \"Bob\", \"age\": 30},\n  {\"nom\": \"Charlie\", \"age\": 20},\n]\n\npersonnes.sort(key=lambda personne: personne[\"age\"])\n\nprint(personnes)\n\n[{'nom': 'Charlie', 'age': 20}, {'nom': 'Alice', 'age': 25}, {'nom': 'Bob', 'age': 30}]\n\n\n\nproduits = [\n  {\"nom\": \"Produit 1\", \"en_stock\": True},\n  {\"nom\": \"Produit 2\", \"en_stock\": False},\n  {\"nom\": \"Produit 3\", \"en_stock\": True},\n]\n\nproduits_en_stock = list(filter(lambda produit: produit[\"en_stock\"], produits))\n\nprint(produits_en_stock) \n\n[{'nom': 'Produit 1', 'en_stock': True}, {'nom': 'Produit 3', 'en_stock': True}]\n\n\nLambda avec Map et Filter Les fonctions map et filter de Python sont presque toujours associées à des expressions lambda. Il est courant de voir des questions sur StackOverflow demandant “qu’est-ce que lambda” répondre avec des exemples de code comme celui-ci :\n\nnumbers = [2, 1, 3, 4, 7, 11, 18]\n\n# Appliquer la fonction map pour obtenir les carrés de chaque élément de numbers\nsquared_numbers = map(lambda n: n**2, numbers)\n\n# Appliquer la fonction filter pour obtenir les nombres impairs de numbers\nodd_numbers = filter(lambda n: n % 2 == 1, numbers)\n\n# Afficher les résultats\nprint(\"Squared numbers:\", squared_numbers)\nprint(\"Odd numbers:\", odd_numbers)\n\nSquared numbers: &lt;map object at 0x1090c7280&gt;\nOdd numbers: &lt;filter object at 0x1090c6fb0&gt;\n\n\n\n# Afficher les résultats\nprint(\"Numbers:\", numbers)\nprint(\"Squared numbers:\", list(squared_numbers))\nprint(\"Odd numbers:\", list(odd_numbers))\n\nNumbers: [2, 1, 3, 4, 7, 11, 18]\nSquared numbers: [4, 1, 9, 16, 49, 121, 324]\nOdd numbers: [1, 3, 7, 11]\n\n\n\n\nLes fonctions et la récursivité\nLa récursivité est un concept fondamental en programmation, et Python est un langage qui le supporte très bien.\nLa récursivité consiste en une fonction qui s’appelle elle-même dans sa propre définition. Cela peut sembler étrange au début, mais c’est une technique très puissante pour résoudre certains types de problèmes, en particulier ceux qui peuvent être décomposés en problèmes plus petits et similaires.\nVoici un exemple simple en Python pour illustrer la récursivité :\ndef nom(): prenom = input(“Nom :”) if prenom == “Ményssa”: return f’ok’ else: nom() nom()\n\ndef countdown(n):\n    if n &lt;= 0:\n        print(\"Lancement terminé!\")\n    else:\n        print(n)\n        countdown(n - 1)\n\ncountdown(5)\n\n5\n4\n3\n2\n1\nLancement terminé!\n\n\nDans cet exemple, la fonction countdown prend un nombre entier n en paramètre. Si n est inférieur ou égal à zéro, la fonction affiche “Lancement terminé!”. Sinon, elle affiche la valeur actuelle de n puis appelle elle-même avec n - 1.\nLa récursivité doit être utilisée avec prudence, car une mauvaise utilisation peut entraîner des erreurs de débordement de pile (stack overflow).\nCela se produit lorsque trop de fonctions récursives sont empilées sur la pile d’appels du programme.\nIl est important de s’assurer qu’il y ait un cas de base dans la récursivité, c’est-à-dire une condition qui arrête les appels récursifs.\nSinon, la fonction continuera à s’appeler elle-même indéfiniment.\nVoici un exemple plus avancé qui utilise la récursivité pour calculer la somme des éléments d’une liste :\n\ndef recursive_sum(arr):\n    if len(arr) == 0:\n        return 0\n    else:\n        return arr[0] + recursive_sum(arr[1:])\n\nmy_list = [1, 2, 3, 4, 5]\nprint(\"La somme des éléments de la liste est:\", recursive_sum(my_list))\n\nLa somme des éléments de la liste est: 15\n\n\nDans cet exemple, la fonction recursive_sum prend une liste en paramètre. Si la liste est vide, elle retourne 0.\nSinon, elle retourne le premier élément de la liste ajouté à la somme des éléments restants, obtenue en appelant récursivement la fonction avec une sous-liste de arr qui exclut le premier élément.\n\n\nGénérateurs et décorateurs\nLes générateurs sont des structures puissantes en Python permettant de créer des itérables de manière efficace et sans consommer beaucoup de mémoire.\nContrairement aux listes, les générateurs produisent des valeurs au fur et à mesure de leur utilisation, ce qui les rend idéaux pour traiter de grandes quantités de données de manière efficace.\n\nUn générateur est une fonction qui utilise le mot-clé yield pour renvoyer des valeurs.\nLorsqu’une fonction contient yield, elle devient un générateur.\nChaque fois que le générateur est appelé, il exécute son code jusqu’à ce qu’il rencontre l’instruction yield.\nÀ ce moment-là, il renvoie la valeur spécifiée et se met en pause, en conservant son état.\nLorsqu’il est rappelé, il reprend à partir de l’instruction yield précédente.\n\n\ndef mon_generateur():\n    yield 1\n    yield 2\n    yield 3\n\n# Utilisation du générateur\ngen = mon_generateur()\n\n# Utilisation d'une boucle for pour itérer sur tous les éléments du générateur\nfor element in gen:\n    print(element)\n\n1\n2\n3\n\n\nDans cet exemple, chaque yield renvoie une valeur successive à chaque appel de next().\nLorsque toutes les valeurs ont été renvoyées, le générateur lève une exception StopIteration.\n\ndef pairs_infinis():\n    n = 0\n    while True:\n        yield n\n        n += 2\n\n# Utilisation du générateur\ngen = pairs_infinis()\n\nfor _ in range(10):\n    print(next(gen)) # Affiche : 0, 2, 4, 6, 8\n\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n\n\n\ndef fibonacci(n):\n    sequence = [0, 1]\n    while len(sequence) &lt; n:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\n# Utilisation de la fonction\nprint(fibonacci(10))  # Affiche les 10 premiers nombres de la séquence Fibonacci\n\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n\n\n\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# Utilisation du générateur\ngen = fibonacci()\nfor _ in range(10):\n    print(next(gen)) # Affiche les 10 premiers nombres de la séquence Fibonacci\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\n\nimport random\nimport string\n\ndef chaine_aleatoire(longueur):\n    while True:\n        yield ''.join(random.choices(string.ascii_letters, k=longueur))\n\n# Utilisation du générateur\ngen = chaine_aleatoire(5)\nfor _ in range(3):\n    print(next(gen)) # Affiche 3 chaînes de 5 caractères aléatoires\n\npjqvu\nahUtb\nlUPBt\n\n\nEn Python, les décorateurs sont des fonctions qui prennent une autre fonction comme argument, ajoutent un comportement supplémentaire à cette fonction, puis la renvoient sans la modifier.\nLes décorateurs utilisent généralement la fonction @decorateur juste avant la définition de la fonction à décorer.\n\ndef decorateur(fonction):\n    def fonction_decoration():\n        print(\"Début de la fonction décorée\")\n        fonction()\n        print(\"Fin de la fonction décorée\")\n    return fonction_decoration\n\n@decorateur\ndef ma_fonction():\n    print(\"Corps de ma fonction\")\n\n# Utilisation de la fonction décorée\nma_fonction()\n\nDébut de la fonction décorée\nCorps de ma fonction\nFin de la fonction décorée\n\n\nDans cet exemple, le décorateur decorateur ajoute un comportement d’impression avant et après l’exécution de la fonction ma_fonction.\nLes décorateurs peuvent également prendre des arguments. Pour cela, il faut ajouter une couche de fonctionnalité supplémentaire pour accepter ces arguments.\n\ndef decorateur_args(argument):\n    def decorateur(fonction):\n        def fonction_decoration():\n            print(\"Début de la fonction décorée avec l'argument :\", argument)\n            fonction()\n            print(\"Fin de la fonction décorée avec l'argument :\", argument)\n        return fonction_decoration\n    return decorateur\n\n@decorateur_args(\"mon_argument\")\ndef ma_fonction():\n    print(\"Corps de ma fonction\")\n\n# Utilisation de la fonction décorée\nma_fonction()\n\nDébut de la fonction décorée avec l'argument : mon_argument\nCorps de ma fonction\nFin de la fonction décorée avec l'argument : mon_argument\n\n\nLes décorateurs sont un aspect avancé de Python, mais ils offrent une puissante fonctionnalité pour étendre et modifier le comportement des fonctions et des méthodes de manière flexible et élégante. En comprenant les principes de base des décorateurs et leur utilisation avancée, vous pouvez améliorer la lisibilité, la réutilisabilité et la modularité de votre code Python.\n\n\nLes décorateurs peuvent retourner une fonction au lieu de la fonction décorée elle-même, ce qui permet de contrôler davantage le comportement de la fonction.\n\n\nLes décorateurs peuvent également être appliqués aux méthodes de classe pour étendre ou modifier le comportement des méthodes.\n\n\nIl est possible d’empiler plusieurs décorateurs sur une même fonction pour ajouter plusieurs couches de fonctionnalités."
  },
  {
    "objectID": "Python.html",
    "href": "Python.html",
    "title": "C’est quoi Python ?",
    "section": "",
    "text": "Essayer de rajouter l’image du créateur\n\nPython est un language de programmation puissant et polyvalent crée en 1989 par Guido Van Rossum, aux Pays-Bas. C’est en profitant d’une semaine de vacances durant les fêtes de Noël, qu’il utilise son ordinateur pour écrire la première version du language. Il décida d’appeler son language ainsi, reliant sa série favorite : Monty Python’s Flying Circus.\nCaractéristiques\nCe language possède de nombreux avantages :\n\nIl est gratuit : possibilité d’être télécharger sur autant de postes que vous souhaitez, ainsi que votre téléphone ;\nIl est multiplateforme : fonctionne sur plusieurs systèmes d’exploitation (Windows, Mac OS X, Linux, Android, iOS, depuis les mini-ordinateurs Raspberry Pi jusqu’aux supercalculateurs.) ;\nIl est facile d’intégration à toute une sélection d’autres languages de programmation fréquemment utilisés, tels que Ruby, C, Java et PHP ;\nIl est orienté objet : permet de créer des entités virtuelles qui répresentent des objets du monde réel, comme une cellule, une protéine ou un atôme, avec leurs propres règles de fonctionnement et dintéractions ;\nIl bénéficie d’une large communauté active et variée. Pour t’aider dans tes challenges techniques, tu aura de multiples plateformes ou blog à ta disposition ;\nIl est relativement simple à prendre en main du fait que même les débutants en programmation peuvent l’utiliser.\n\nEnfin, Python est un language qui ne veillit pas. Les développeurs mettent à jour le language et développe de nouvelles fonctionnalités régulièrement. Tu peux te référer à la documentation officielle du site https://www.python.org .\nA contrario, la faiblesse de Python reste sa lenteur, comparé à Java ou C, Python demande plus de temps d’exécution.\nL’indentation\nDans Python, l’indentation est une importance capitale permettant de délimiter les blocs de code. Il est conventionnel d’utiliser quatre espaces pour l’indentation, plutôt que des tabulations."
  },
  {
    "objectID": "Exceptions.html",
    "href": "Exceptions.html",
    "title": "Gestion des exceptions",
    "section": "",
    "text": "Une exception est une erreur qui se produit pendant l’exécution du programme, contrairement aux erreurs de syntaxe qui sont détectées avant l’exécution. Les exceptions peuvent être dues à diverses raisons, telles que des entrées invalides, des opérations mathématiques impossibles, des manipulations de fichiers incorrectes, etc.\nVoici quelques exemples d’exceptions fréquemment rencontrées :\n\nIndexError : Se produit lorsqu’on tente d’accéder à un index qui n’existe pas dans une séquence (comme une liste ou un tuple).\n\nma_liste = [\"A\", 3, \"serpent\"]\nelement = ma_liste[5]  # IndexError car l'index 5 n'existe pas dans une liste de taille 3\n\nValueError : Apparaît lorsqu’une fonction reçoit un argument de type correct mais d’une valeur inappropriée.\n\nnombre = int(\"123373829173487472474\")\nnombre\nnombre = int(\"abc\")  # ValueError car \"abc\" ne peut pas être converti en entier\n\nTypeError : Se produit lorsqu’une opération ou fonction est appliquée à un objet d’un type inapproprié.\n\nsomme = 10 + 5 \nsomme\n\"message\" + \" : voici mon texte\" \nsomme = \"texte\" + 5  # TypeError car on ne peut pas ajouter une chaîne de caractères et un entier\nsomme = 5  + \"5\"\n\nFileNotFoundError : Levée lorsqu’une tentative de lecture d’un fichier échoue parce que le fichier n’existe pas.\n\n# with open(\"../data/Orgueil_et_Prejuges.txt\", \"r\", encoding = 'utf-8') as fichier:\n#     contenu = fichier.read()  \n\n# print(contenu)\nwith open(\"fichier_inexistant.txt\", \"r\") as fichier:\n    contenu = fichier.read()  # FileNotFoundError si \"fichier_inexistant.txt\" n'existe pas\n\nZeroDivisionError : Se produit lorsqu’une division par zéro est tentée.\n\nresultat = 10 / 0  # ZeroDivisionError car on ne peut pas diviser par zéro\n\nNameError : Se produit lorsqu’une variable n’est pas définie dans le contexte actuel.\n\ndef ma_fonction():\n    variable_a_afficher = \"Bonjour\"\n    print(variable_a_afficher)\n\nma_fonction()\nma_fonction()\nma_fonction()\nprint(variable_a_afficher)  # NameError car 'variable_a_afficher' n'est pas définie en dehors de la fonction"
  },
  {
    "objectID": "Exceptions.html#définition",
    "href": "Exceptions.html#définition",
    "title": "Gestion des exceptions",
    "section": "",
    "text": "Une exception est une erreur qui se produit pendant l’exécution du programme, contrairement aux erreurs de syntaxe qui sont détectées avant l’exécution. Les exceptions peuvent être dues à diverses raisons, telles que des entrées invalides, des opérations mathématiques impossibles, des manipulations de fichiers incorrectes, etc.\nVoici quelques exemples d’exceptions fréquemment rencontrées :\n\nIndexError : Se produit lorsqu’on tente d’accéder à un index qui n’existe pas dans une séquence (comme une liste ou un tuple).\n\nma_liste = [\"A\", 3, \"serpent\"]\nelement = ma_liste[5]  # IndexError car l'index 5 n'existe pas dans une liste de taille 3\n\nValueError : Apparaît lorsqu’une fonction reçoit un argument de type correct mais d’une valeur inappropriée.\n\nnombre = int(\"123373829173487472474\")\nnombre\nnombre = int(\"abc\")  # ValueError car \"abc\" ne peut pas être converti en entier\n\nTypeError : Se produit lorsqu’une opération ou fonction est appliquée à un objet d’un type inapproprié.\n\nsomme = 10 + 5 \nsomme\n\"message\" + \" : voici mon texte\" \nsomme = \"texte\" + 5  # TypeError car on ne peut pas ajouter une chaîne de caractères et un entier\nsomme = 5  + \"5\"\n\nFileNotFoundError : Levée lorsqu’une tentative de lecture d’un fichier échoue parce que le fichier n’existe pas.\n\n# with open(\"../data/Orgueil_et_Prejuges.txt\", \"r\", encoding = 'utf-8') as fichier:\n#     contenu = fichier.read()  \n\n# print(contenu)\nwith open(\"fichier_inexistant.txt\", \"r\") as fichier:\n    contenu = fichier.read()  # FileNotFoundError si \"fichier_inexistant.txt\" n'existe pas\n\nZeroDivisionError : Se produit lorsqu’une division par zéro est tentée.\n\nresultat = 10 / 0  # ZeroDivisionError car on ne peut pas diviser par zéro\n\nNameError : Se produit lorsqu’une variable n’est pas définie dans le contexte actuel.\n\ndef ma_fonction():\n    variable_a_afficher = \"Bonjour\"\n    print(variable_a_afficher)\n\nma_fonction()\nma_fonction()\nma_fonction()\nprint(variable_a_afficher)  # NameError car 'variable_a_afficher' n'est pas définie en dehors de la fonction"
  },
  {
    "objectID": "Exceptions.html#traitement-des-exceptions",
    "href": "Exceptions.html#traitement-des-exceptions",
    "title": "Gestion des exceptions",
    "section": "Traitement des exceptions",
    "text": "Traitement des exceptions\nLa gestion des exceptions est un aspect crucial de la programmation pour plusieurs raisons :\n\nRobustesse : Elle permet à un programme de gérer des situations d’erreur de manière gracieuse sans s’arrêter brusquement.\nContrôle du Flux : Elle offre un moyen de diriger le flux d’un programme lorsque des situations exceptionnelles se produisent.\nDébogage Facilité : Elle aide à identifier les causes des erreurs et à les gérer efficacement.\nSécurité : Elle permet de gérer des situations potentiellement dangereuses, comme la lecture de fichiers corrompus ou la gestion de données utilisateur erronées.\n\n\nTry-Except\nLa syntaxe de base pour la gestion des exceptions en Python utilise les instructions try et except.\nVoici un exemple simple :\ntry:\n    # Bloc de code à essayer\n    result = 10 / 0\nexcept ZeroDivisionError:\n    # Ce bloc est exécuté en cas d'erreur ZeroDivisionError\n    print(\"Division par zéro !\")\nDans cet exemple, si le code dans le bloc try cause une ZeroDivisionError, le programme ne s’arrêtera pas. Au lieu de cela, il exécutera le code dans le bloc except.\nresult = 10 / 0\ntry:\n    # Bloc de code à essayer\n    result = 10 / 0\nexcept ZeroDivisionError:\n    # Ce bloc est exécuté en cas d'erreur ZeroDivisionError\n    print(\"Division par zéro !\")\ndef gestion_index_error(liste, index):\n    try:\n        return liste[index]\n    except IndexError as e:\n        return f\"Ce n'est pas possible, Erreur d'index  : {e}\"\n\n# Test\nma_liste = [\"A\", 3, \"serpent\"]\nprint(gestion_index_error(ma_liste, 1))\nprint(gestion_index_error(ma_liste, 5))\ndef conversion_en_entier(entree):\n    try:\n        return int(entree)\n    except ValueError as e:\n        return f\"La conversion n'est pas possible, Erreur de valeur : {e}\"\n\n# Test\nval_entree = \"190\"\nprint(conversion_en_entier(val_entree))\nval_entree = \"Robert\"\nprint(conversion_en_entier(val_entree))\ndef additionner(a, b):\n    try:\n        return a + b\n    except TypeError as e:\n        return f\"Erreur de type : {e}\"\n\n# Test\nprint(additionner(2, 5))\nprint(additionner(\"texte\", 5))\ndef lire_fichier(nom_fichier):\n    try:\n        with open(nom_fichier, \"r\", encoding = 'utf-8') as fichier:\n            return fichier.read()\n    except FileNotFoundError as e:\n        return f\"Erreur de fichier non trouvé : {e}\"\n\n# Test\n# data = lire_fichier(\"../data/Orgueil_et_Prejuges.txt\")\n# print(data)\n\ndata = lire_fichier(\"../data/fichier_inexistant.txt\")\nprint(data)\ndef diviser(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError as e:\n        return f\"Erreur de division par zéro : {e}\"\n\n# Test\nprint(diviser(10, 0))\ndef acceder_variable(nom_variable):\n    try:\n        return eval(nom_variable) # renvoie contenu de la variable\n    except NameError as e:\n        return f\"Erreur de nom : {e}\"\n\n# Test   \nprint(acceder_variable(\"val_entree\")) \nprint(acceder_variable(\"variable_inexistante\"))\ndef conversion_en_entier(chaine):\n    try:\n        return int(chaine)\n    except ValueError as e:\n        return f\"Erreur de valeur : {e}\"\n\ndef additionner(a, b):\n    try:\n        return a + b\n    except TypeError as e:\n        return f\"Erreur de type : {e}\"\n\ndef convertir_et_additionner(chaine1, chaine2):\n    valeur1 = conversion_en_entier(chaine1)\n    valeur2 = conversion_en_entier(chaine2)\n\n    # Vérification si les conversions se sont bien passées\n    if isinstance(valeur1, int) and isinstance(valeur2, int):\n        return additionner(valeur1, valeur2)\n    else:\n        # Retourne les messages d'erreur si la conversion a échoué\n        return valeur1 if isinstance(valeur1, str) else valeur2\n\n# Test\nprint(convertir_et_additionner(\"3\", \"4\"))  \nprint(convertir_et_additionner(3.8, \"4\"))  \n# print(convertir_et_additionner(\"a\", \"4\"))\nVous pouvez avoir plusieurs blocs except pour gérer différents types d’exceptions. Cela permet de réagir de manière appropriée à différentes erreurs qui peuvent survenir.\ntry:\n    # Tentative d'exécution de code\n    ...\nexcept TypeError:\n    # Gestion de TypeError\n    ...\nexcept ValueError:\n    # Gestion de ValueError\n    ...\ndef operation_complexe(a, b, c):\n    try:\n        resultat = (a + b) / c\n        return resultat\n    except TypeError as e:\n        return f\"Erreur de type : {e}\"\n    except ZeroDivisionError as e:\n        return f\"Erreur de division par zéro: {e}\"\n    except Exception as e:\n        return f\"Autre erreur : {e}\"\n\n# Exemple d'utilisation\n\nprint(operation_complexe(1, 3, 2))  \nprint(operation_complexe(1, 2, 0))  \nprint(operation_complexe(1, \"deux\", 3))\nDans cet exemple, la fonction operation_complexe essaie d’effectuer une opération qui peut lever plusieurs types d’exceptions :\n\nTypeError si a, b, ou c n’est pas un nombre.\nZeroDivisionError si c est zéro.\nException comme un filet de sécurité pour attraper d’autres types d’exceptions inattendues.\n\nL’utilisation de plusieurs blocs except permet de donner des réponses spécifiques à chaque type d’erreur, améliorant ainsi la lisibilité et la maintenance du code.\n\n\nFinally\nLe bloc finally en Python est utilisé pour définir des actions qui doivent être exécutées après les blocs try et except, peu importe si une exception a été levée ou non.\nCe bloc est souvent utilisé pour des opérations de nettoyage qui doivent s’exécuter dans tous les cas, comme la fermeture de fichiers ou la libération de ressources externes.\ndef calculer_division(a, b):\n    try:\n        resultat = a / b\n        return resultat\n    except ZeroDivisionError:\n        return \"Une division par zéro a été tentée.\"\n    finally:\n        print(\"Opération terminée (réussie ou non).\")\n        return a + b\n\n# Exemple d'utilisation\nprint(calculer_division(10, 2))  # Pas d'erreur, affiche le résultat et le message de finally\nprint(calculer_division(10, 0))  # Attrape ZeroDivisionError, affiche le message d'erreur et le message de finally\ndef exemple_finally():\n    try:\n        fichier = open(\"../data/Orgueil_et_Prejuges.txt\", \"r\")\n        contenu = fichier.read()\n        return contenu\n    except FileNotFoundError as e:\n        return f\"Erreur : {e}\"\n    finally:\n        fichier.close()\n        print(\"Fichier fermé.\")\n\n# Exemple d'utilisation\nprint(exemple_finally())\n\n\nElse\nUtilisez else lorsque vous avez besoin d’exécuter du code qui ne doit s’exécuter que si le bloc trv s’est exécuté sans erreur, mais avant d’exécuter le code dans le bloc finally.\ndef exemple_else(chaine):\n    try:\n        num = int(chaine)\n    except ValueError:\n        return \"Ce n'est pas un nombre valide.\"\n    else:\n        return f\"Conversion réussie : {num}\"\n\n# Exemple d'utilisation\nprint(exemple_else(\"1233717237\"))\nprint(exemple_else(\"abc\"))\ndef division_avec_verification(a, b):\n    try:\n        resultat = a / b\n    except ZeroDivisionError:\n        return \"Une division par zéro a été tentée.\"\n    else:\n        if resultat &gt; 50:\n            return \"Le résultat est étonnamment grand.\"\n    finally:\n        print(\"Opération de division terminée (réussie ou non).\")\n# Exemple d'utilisation\nprint(division_avec_verification(1000, 10))  # Division réussie, vérification dans 'else', puis 'finally'\nprint(division_avec_verification(10, 0))    # Attrape ZeroDivisionError, puis exécute 'finally'"
  },
  {
    "objectID": "Exceptions.html#assertions",
    "href": "Exceptions.html#assertions",
    "title": "Gestion des exceptions",
    "section": "Assertions",
    "text": "Assertions\nL’instruction assert est utilisée pour tester si une condition est vraie. Si la condition est fausse, AssertionError est levée.\nLes assertions sont principalement utilisées comme un moyen de débogage, pour vérifier des conditions internes, tandis que les exceptions sont utilisées pour gérer des erreurs et des conditions exceptionnelles dans le flux normal du programme.\ndef diviser_par_deux(n):\n    assert n % 2 == 0, \"Le nombre doit être pair.\"\n    return n / 2\n# Exemple d'utilisation\nprint(diviser_par_deux(10))  # Fonctionne bien\nprint(diviser_par_deux(3))  # Déclenche AssertionError\ndef ma_fonction(x):\n  assert isinstance(x, int), \"La variable doit être un nombre entier\"\n  # ...\n\nma_fonction(10)  # OK\nma_fonction(\"toto\")  # Assertion error\ndef ma_fonction(x):\n  assert x &gt; 0, \"La variable doit être positive\"\n  # ...\n\nma_fonction(5)  # OK\nma_fonction(-1)  # Assertion error\ndef ma_fonction(x, y):\n  assert x != y, \"Les deux variables doivent être différentes\"\n  # ...\n\ntry:\n  ma_fonction(10, 10)\nexcept AssertionError:\n  print(\"Les deux variables sont identiques\")"
  },
  {
    "objectID": "Exceptions.html#raise",
    "href": "Exceptions.html#raise",
    "title": "Gestion des exceptions",
    "section": "Raise",
    "text": "Raise\nL’instruction raise en Python est un outil crucial pour la gestion des exceptions, permettant aux développeurs de déclencher explicitement des exceptions lorsqu’une condition spécifique se produit dans le programme.\nLes exceptions levées avec raise peuvent être capturées et gérées en amont, permettant aux développeurs de réagir de manière appropriée aux différents types de problèmes qui peuvent survenir, améliorant ainsi la robustesse et la fiabilité du code.\nDans l’exemple suivant, si set_age est appelée avec un âge négatif, une ValueError est levée, indiquant que l’âge ne peut pas être négatif.\ndef set_age(age):\n    if age &lt; 0:\n        raise ValueError(\"L'âge ne peut pas être négatif.\")\n    print(f\"Âge défini à {age} ans.\")\n\ntry:\n    set_age(-10)\nexcept ValueError as e:\n    print(e)\nIci, diviser lève une ZeroDivisionError si le diviseur (b) est zéro. Cela empêche l’exécution d’une division par zéro, ce qui entraînerait une erreur en Python.\ndef diviser(a, b):\n    if b == 0:\n        raise ZeroDivisionError(\"Le diviseur ne peut pas être zéro.\")\n    return a / b\n\ntry:\n    resultat = diviser(10, 0)\nexcept ZeroDivisionError as e:\n    print(e)\ndef ma_fonction(x):\n  if x &lt; 0:\n    raise ValueError(\"La variable doit être positive\")\n  # ...\n\nma_fonction(10)  # OK\nma_fonction(-1)  # ValueError: La variable doit être positive\ndef ma_fonction(x):\n  try:\n    y = 1 / x\n  except ZeroDivisionError:\n    raise ValueError(\"La variable ne peut pas être égale à 0\")\n  # ...\n\nma_fonction(10)  # OK\nma_fonction(0)  # ValueError: La variable ne peut pas être égale à 0"
  },
  {
    "objectID": "Exceptions.html#en-résumé",
    "href": "Exceptions.html#en-résumé",
    "title": "Gestion des exceptions",
    "section": "En résumé",
    "text": "En résumé\nVoici quelques-unes des exceptions intégrées courantes en programmation Python ainsi que les erreurs qui les provoquent.\n\n\n\n\n\n\n\n\nException\nCause de l’erreur\n\n\n\n\n\nAsseretionError\nLevée lorsque l’instruction assert échoue\n\n\n\nAttributeError\nLevée lorsque l’assignation ou la référence à un attribut échoue\n\n\n\nEOFError\nLevée lorsque input() atteint la fin du fichier\n\n\n\nFloatingPointError\nLevée lorsqu’une opération sur les nombres à virgule flottante échoue\n\n\n\nGeneratorExit\nLevée lorsque la méthode close() d’un générateur est appelée\n\n\n\nImportError\nLevée lorsque le module importé n’est pas trouvé\n\n\n\nIndexError\nLevée lorsque l’index d’une séquence est hors de portée\n\n\n\nKeyError\nLevée lorsque une clé n’est pas trouvée dans un dictionnaire\n\n\n\nKeyboardInterrupt\nLevée lorsque l’utilisateur appuie sur la touche d’interruption (Ctrl+C ou Suppr)\n\n\n\nMemoryError\nLevée lorsqu’une opération manque de mémoire\n\n\n\nNameError\nLevée lorsqu’une variable n’est pas trouvée dans la portée locale ou globale\n\n\n\nNotImplementedError\nevée par des méthodes abstraites\n\n\n\nOSError\nLevée lorsqu’une opération système provoque une erreur liée au système\n\n\n\nOverflowError\nLevée lorsque le résultat d’une opération arithmétique est trop grand pour être représenté\n\n\n\nReferenceError\nLevée lorsqu’une référence faible est utilisée pour accéder à un référent collecté par le ramasse-miette\n\n\n\nRuntimeError\nLevée lorsqu’une erreur ne rentre dans aucune autre catégorie\n\n\n\nStopIteration\nLevée par next() pour indiquer qu’il n’y a plus d’élément à renvoyer par l’itérateur\n\n\n\nSyntaxError\nLevée par l’analyseur lorsque une erreur de syntaxe est rencontrée\n\n\n\nIndentationError\nLevée lorsqu’il y a une indentation incorrecte\n\n\n\nTabError\nLevée lorsque l’indentation est composée de tabulations et d’espaces inconsistants\n\n\n\nSystemError\nLevée lorsque l’interpréteur détecte une erreur interne\n\n\n\nSystemExit\nLevée par la fonction sys.exit()\n\n\n\nTypeError\nLevée lorsqu’une fonction ou une opération est appliquée à un objet de type incorrect\n\n\n\nUnboundLocalError\nLevée lorsqu’une référence est faite à une variable locale dans une fonction ou une méthode, mais aucune valeur n’a été liée à cette variable\n\n\n\nUnicodeDecodeError\nLevée lorsqu’une erreur liée à Unicode se produit pendant le décodage\n\n\n\nValueError\nLevée lorsqu’une fonction reçoit un argument de type correct mais de valeur incorrecte\n\n\n\nZeroDivisionError\nLevée lorsque le deuxième opérande de l’opération de division ou de modulo est zéro\n\n\n\n\nNous pouvons voir toutes les exceptions intégrées en utilisant la fonction locale intégrée comme suit :\nprint(dir(locals()['__builtins__']))"
  }
]